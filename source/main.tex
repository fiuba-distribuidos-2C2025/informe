\documentclass[titlepage,a4paper]{article}

\usepackage{a4wide}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=blue,bookmarksopen=true]{hyperref}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage[margin=0.65in]{geometry}

\pagestyle{fancy} % Encabezado y pie de página
\fancyhf{}
\fancyhead[L]{TP Diseño - Coffee Shop Analysis}
\fancyhead[R]{Sistemas Distribuidos I - FIUBA}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}
\begin{titlepage} % Carátula
	\hfill\includegraphics[width=6cm]{logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{TP Diseño - Coffee Shop Analysis}
    \vskip2cm
    \Large [75.74] Sistemas Distribuidos I\\
    Segundo cuatrimestre de 2025 
    \vfill
    \begin{tabular}{ | l | l | l |}
      \hline
      Avecilla, Ignacio & 105067& iavecilla@fi.uba.ar\\ \hline
      Avila, Gaston& 104482& gavila@fi.uba.ar\\ \hline
      Muñoz, Juan Martín & 106699& jmmunoz@fi.uba.ar\\ \hline
  	\end{tabular}
    \vfill
    \vfill
\end{titlepage}

\tableofcontents % Índice general
\newpage

\section{Alcance}\label{sec:alcance}
\paragraph{El presente informe presenta la documentación de un sistema distribuido flexible, robusto y escalable, capaz de resolver las consultas otorgadas por la catedra con una cantidad de unidades de procesamiento mayor o igual a uno.}

\paragraph{Las consultas a resolver son:}
\begin{enumerate}
    \item Transacciones (Id y monto) realizadas durante 2024 y 2025 entre las 06:00 AM y las
11:00 PM con monto total mayor o igual a 75.
\item Productos más vendidos (nombre y cant) y productos que más ganancias han generado
(nombre y monto), para cada mes en 2024 y 2025.
\item TPV (Total Payment Value) por cada semestre en 2024 y 2025, para cada sucursal, para
transacciones realizadas entre las 06:00 AM y las 11:00 PM.
\item Fecha de cumpleaños de los 3 clientes que han hecho más compras durante 2024 y
2025, para cada sucursal.
\end{enumerate}

\section{Arquitectura}\label{sec:arquitectura}

\subsection{Vista Física}
\paragraph{Se muestra la enteridad del sistema y las conexiones existentes entre las diversas entidades del sistema.}

\subsubsection{Diagrama de Robustez}
\paragraph{Se visualizan todos los componentes que interactuan en nuestro diseño, desde la interacción inicial del cliente, hasta la finalización del procesado de todas las consultas.}
\begin{itemize}
    \item Los trabajadores se comunican a través de la inserción y consumo de datos en diversas colas, las cuales pueden ser accedidas por multiples trabajadores concurrentemente. Se distinguen 2 tipos de cola segun como se distribuyen los mensajes:
\begin{figure}[H]
\centering
    \includegraphics[width=0.30\linewidth]{colas.png}
\end{figure}
\end{itemize}
\begin{itemize}
    \item Las entidades que pueden ser escaladas a multiples unidades de computo se representan de la siguiente forma:
\begin{figure}[H]
\centering
    \includegraphics[width=0.15\linewidth]{multiple_computo.png}
\end{figure}
\end{itemize}
\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{robustez.png}
\end{figure}

Cada worker tiene asociado una cola de input y una cola de output, salvo los aggregators que obtienen resultados de muchos workers en una unica cola y se encargan de agregar los resultados.

Las colas marcadas como tipo "broadcast" se basan en multiples colas cada una de ellas conectadas a un worker de salida, el worker que se encarga de producir en esta cola iterara cada una de ellas dejando el mismo dato en todas ellas.

Por otro lado el manejo de EOF (end of file) se realiza mediante un mensaje especial que indica a los workers que no habra mas datos a procesar. El request handler encola ese mensaje en todas las colas de entrada y los sucesivos workers iran propagando el mensaje de EOF a medida que terminan su trabajo, una vez que todos los EOF correspondientes lleguen a las colas de resultados entonces el Response Builder arma la respuesta y la envia al cliente indicando que una query ya fue completamente procesada

Todos los resultaados seran insertados en diferentes colas, una para cada consulta, el Response builder sera el encargado de leer de ellas y mandar una unica respuesta para la consulta correspondiente

A continuación, se muestran cuatro extractos del diagrama de robustez, destacando los aspectos más relevantes de cada consulta.

\subsection*{Consulta 1}
Es la más simple. Requiere tres filtros encadenados (\textbf{Year Filter}, \textbf{Hour Filter} y \textbf{Amount Filter}).  
Cada etapa puede escalarse mediante un esquema \textbf{producer--consumer}: los workers consumen mensajes de la cola, procesan la entrada y deciden si reenviarla o descartarla.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{consulta1.png}
    \caption{Diagrama de robustez - Consulta 1}
\end{figure}


\subsection*{Consulta 2}
Incorpora las colas de tipo \textbf{fan-out (broadcast)} para mandar un mismo mensaje a multiples workers:

\begin{itemize}
    \item \textbf{Transactions with profit and total amount}: En este caso contenemos una unica cola que va a tener todos los resultados parciales de nuestro groupers segun la data que pudieron obtener de la cola anterior, en este caso el mas profit and quantity filter sera el encargado de no solo filtrar los resultados si no tambien agregarlos para tener los resultados finales
    \item \textbf{Menu Items} (fan-out): los datos se difunden a todos los \texttt{Menu Item Joiner}. Estos almacenan en memoria la lista de ítems (pocos y estáticos) y luego consumen de la cola \textbf{Items with max profit and qty} (producer--consumer) para realizar los joins. Como el total de items del menú siempre son 8 entonces podemos cargarlos en memoria sin problemas.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{consulta2.png}
    \caption{Diagrama de robustez - Consulta 2}
\end{figure}

\subsection*{Consulta 3}
Utiliza una cola de tipo \textbf{broadcast}:

\begin{itemize}
    \item \textbf{Transactions per semester}: Siguiendo la logica anterior tenemos un único aggregator que se encarga de obtener los datos parciales de los groupers y los agrega en un solo resultado final, el cual sera enviado a la cola de \textbf{Transactions grouped}.
    \item \textbf{Stores} (fan-out): los datos se difunden a todos los \texttt{Store ID Joiner}. Estos almacenan en memoria la lista de ítems (pocos y estáticos) y luego consumen de la cola \textbf{Transactions grouped} (producer--consumer) para realizar los joins. Como el total de items del menú siempre son 10 entonces podemos cargarlos en memoria sin problemas.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{consulta3.png}
    \caption{Diagrama de robustez - Consulta 3}
\end{figure}

\subsection*{Consulta 4}
Requiere dos colas de tipo \textbf{broadcast}:

\begin{itemize}
    \item \textbf{Transactions per Store ID - User ID}: Al igual que en los casos anteriores, tenemos un agregator que recibe los datos parciales de los groupers y los agrega en un solo resultado final, el cual sera enviado a la cola de \textbf{Top 3 transactions per store}.
    \item \textbf{Top 3 transactions per store}: Estas colas se comportan como si fuera un fan-out exchange donde todos los resultados llegan a todos los workers, ya que estos resultados nunca son muy grandes (solo 3 resultados por cada sucursal) y al tenerlo en memoria, los workers pueden realizar los joins de manera correcta.
\end{itemize}


\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{consulta4.png}
    \caption{Diagrama de robustez - Consulta 4}
\end{figure}

\subsubsection{Diagrama de Despliegue}

Podemos ver como los toda comunicación interna es realizada mediante RabbitMQ (el middleware).

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{despliegue.png}
\end{figure}


\subsection{Vista Lógica}
\subsubsection{DAG}
\begin{figure}[H]
\centering
    \includegraphics[width=1\linewidth]{DAG.png}
\end{figure}
Se visualiza un directed acyclic graph que muestra el flujo de datos siendo atravezado por los distintos componentes, comenzando de arriba hacia abajo. Los trabajadores (workers) se dividen en agrupadores (groupers), acumuladores (joiners), agregadores (aggregators) y filtradores (filters). Las fuentes de información inicial, y donde se almacena finalmente lo procesado son a nivel de implementación colas.
Los aggregators son los nodos encargados de obtener data de los groupers y acumularla en un solo resultado final segun sea necesario, de esta manera los groupers pueden recibir cualquier tipo de data y agrupar en base a los datos que le lleguen.


\subsection{Vista de Desarrollo}
Aquí podemos visualizar como esta planeada la arquitectura del sistema desde la perspectiva del código. Se divide el sistema en distintos modulos para Cliente, Worker, Request Controller, Response builder y Middleware.

\subsubsection{Diagrama de Paquetes}
Se muestran los distintos modulos a implementar:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{cliente.png}
    \caption{El cliente tiene la responsabilidad de comunicarse con el Request controller, siguiendo los parametros especificados en su configuración.}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{worker.png}
    \caption{Los workers tienen la tarea de filtrar, acumular o agrupar los diversos tipos de datos que lean de las colas a las que estes subscriptos.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{request_controller.png}
    \caption{La tarea del request controller es interpretar los mensajes del cliente, para poder derivarlos a las diferentes colas de RabbitMQ.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\linewidth]{middleware.png}
    \caption{El Middleware tiene un manejo de cola y cliente, asi como también las librerias necesarias para el interfazado con RabbitMQ}
\end{figure}

\subsection{Vista de Procesos}

\paragraph{Se representa la interacción entre los componentes del sistema, su forma de comunicación de principio a fin. Es posible visualizar la concurrencia del sistema, asi como también la escalabilidad y distribuición de tareas.}

\subsubsection{Diagrama de Actividad}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{actividad.png}
\end{figure}
\paragraph{Se muestra el parcialmente el proceso de obtener los productos más vendidos y que más ganancias han generado, para cada mes, en este caso se representa solamente la parte de mayor complejidad* de obtención, la de mayor valor y no solo mayor cantidad de ventas.}

\paragraph{*Se considera más complejo debido a que los pasos necesarios para obtener este dato es superior a la de calcular el producto más vendido en cantidad.}

\subsubsection{Diagrama de Secuencia}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{secuencia.png}
\end{figure}
\paragraph{Podemos ver como el cliente desde la terminal inicializa el programa, el cual establece conexión con el sistema mediante el Request Handler. La comunicación entre ellos consistira en enviar todos los datos necesarios en bucle, cada mensaje transmitido por el cliente incluye un header informando el tipo de archivo transmitido, el tamaño del payload, y un bit que indica si hay datos pendientes por transmitir posteriores a ese mensaje. Una vez que ya no haya nada más que enviar, el Middleware le enviará el programa el resultado final, el cual sera mostrado por terminal al usuario.}
\end{document}
